<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>SuperTiger’s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="白话文转述">
<meta property="og:type" content="website">
<meta property="og:title" content="SuperTiger’s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="SuperTiger’s Blog">
<meta property="og:description" content="白话文转述">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="SuperTg">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="SuperTiger’s Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">SuperTiger’s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-react-note-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/react-note-1/" class="article-date">
  <time class="dt-published" datetime="2021-07-07T06:54:30.000Z" itemprop="datePublished">2021-07-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/react-antd/">react antd</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/react-note-1/">react antd之动态创建表单</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="react-antd4-x-动态创建表单"><a href="#react-antd4-x-动态创建表单" class="headerlink" title="react antd4.x 动态创建表单"></a>react antd4.x 动态创建表单</h2><p>-先上效果图<br><img src="/react-note-1/ui.png" alt="&#39;效果图&#39;"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;Form.Item&gt;</span><br><span class="line">        &lt;Form.List name=&quot;groups&quot; className=&quot;myInput&quot;&gt;</span><br><span class="line">          &#123;(fields, &#123; add, remove &#125;, &#123; errors &#125;) =&gt; (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">              &#123;fields.map((field, index) =&gt; (</span><br><span class="line">                &lt;Space key=&#123;field.key&#125; align=&quot;baseline&quot; size=&#123;8&#125;&gt;</span><br><span class="line">                  &lt;Form.Item</span><br><span class="line">                    getValueFromEvent=&#123;(event) =&gt; &#123;</span><br><span class="line">                      return event.target.value.replace(/\s+/g, &#x27;&#x27;);</span><br><span class="line">                    &#125;&#125;</span><br><span class="line">                    &#123;...field&#125;</span><br><span class="line">                    name=&#123;[field.name, &#x27;name&#x27;]&#125;</span><br><span class="line">                    fieldKey=&#123;[field.fieldKey, &#x27;name&#x27;]&#125;</span><br><span class="line">                  &gt;</span><br><span class="line">                    &lt;Input</span><br><span class="line">                      placeholder=&quot;请输入名称，最长支持50个字符&quot;</span><br><span class="line">                      style=&#123;&#123; width: &#x27;250px&#x27; &#125;&#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                  &lt;/Form.Item&gt;</span><br><span class="line">                  &lt;Form.Item</span><br><span class="line">                    name=&#123;[field.name, &#x27;ratio&#x27;]&#125;</span><br><span class="line">                  &gt;</span><br><span class="line">                    &lt;Input</span><br><span class="line">                      onChange=&#123;(e) =&gt; handleChange(e, index)&#125;</span><br><span class="line">                      autoComplete=&quot;off&quot;</span><br><span class="line">                    /&gt;</span><br><span class="line">                  &lt;/Form.Item&gt;</span><br><span class="line">                  &lt;Form.Item</span><br><span class="line">                    name=&#123;[field.name, &#x27;number&#x27;]&#125;</span><br><span class="line">                    fieldKey=&#123;[field.fieldKey, &#x27;number&#x27;]&#125;</span><br><span class="line">                  &gt;</span><br><span class="line">                    &lt;Input</span><br><span class="line">                      placeholder=&quot;覆盖人数&quot;</span><br><span class="line">                    /&gt;</span><br><span class="line">                  &lt;/Form.Item&gt;</span><br><span class="line">                  &#123;fields.length &gt; 1 ? (</span><br><span class="line">                    &lt;MinusCircleOutlined</span><br><span class="line">                      onClick=&#123;(e) =&gt; &#123;</span><br><span class="line">                        remove(field.name);</span><br><span class="line">                      &#125;&#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                  ) : null&#125;</span><br><span class="line">                &lt;/Space&gt;</span><br><span class="line">              ))&#125;</span><br><span class="line">              &lt;Form.Item&gt;</span><br><span class="line">                &lt;span className=&#123;style.addField&#125; onClick=&#123;() =&gt; add()&#125;&gt;</span><br><span class="line">                  &lt;PlusOutlined style=&#123;&#123; marginRight: &#x27;4px&#x27; &#125;&#125; /&gt;</span><br><span class="line">                  添加</span><br><span class="line">                &lt;/span&gt;</span><br><span class="line">              &lt;/Form.Item&gt;</span><br><span class="line">              &lt;Form.ErrorList errors=&#123;errors&#125; /&gt;</span><br><span class="line">            &lt;/&gt;</span><br><span class="line">          )&#125;</span><br><span class="line">        &lt;/Form.List&gt;</span><br><span class="line">      &lt;/Form.Item&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>因为用的&lt;Form.List&gt;&lt;/Form.List&gt; 那么初始化数据中就要有个字段对应 Form.List 中的 name 字段. 我这里是 groups</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const initialValues =&#123;</span><br><span class="line">    ...// 其他字段</span><br><span class="line">    // 动态表单字段</span><br><span class="line">    groups:[</span><br><span class="line">        &#123;name:&#x27;superTiger1&#x27;,ratio:&#x27;&#x27;,number:&#x27;&#x27;&#125;,</span><br><span class="line">        &#123;name:&#x27;superTiger2&#x27;,ratio:&#x27;&#x27;,number:&#x27;&#x27;&#125;,</span><br><span class="line">        &#123;name:&#x27;superTiger3&#x27;,ratio:&#x27;&#x27;,number:&#x27;&#x27;&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先拿到 form 实例:<br><br>const [form] = Form.useForm();<br><br>然后在 useEffect()中通过 setFieldsValue 方法进行初始化:<br><br>form.setFieldsValue({ …initialValues });</p>
<h3 id="回显"><a href="#回显" class="headerlink" title="回显"></a>回显</h3><p><img src="/react-note-1/back.png" alt="&#39;效果图&#39;"><br>ajax 获取数据后,也是通过 form.setFieldsValue({ …ajaxData })来回显</p>
<h3 id="回显设置不可编辑-新添加的则可以编辑"><a href="#回显设置不可编辑-新添加的则可以编辑" class="headerlink" title="回显设置不可编辑,新添加的则可以编辑"></a>回显设置不可编辑,新添加的则可以编辑</h3><p><img src="/react-note-1/back1.png" alt="&#39;效果图&#39;"></p>
<ol>
<li>先在 ajax 的数据中添加标志不可编辑属性</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groups.map(item =&gt;&#123;</span><br><span class="line">    item.disabled:true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>给要实现不可编辑的控件添加 disabled 属性</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;Input</span><br><span class="line">    disabled=&#123;disabled(index)&#125;</span><br><span class="line">    autoComplete=&quot;off&quot;</span><br><span class="line">    placeholder=&quot;请输入分组名称，最长支持50个字符&quot;</span><br><span class="line">    style=&#123;&#123; width: &#x27;250px&#x27; &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过 groups 设置属性</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const disabled = (index) =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">      props.getFieldValue(&#x27;groups&#x27;)[index] &amp;&amp;</span><br><span class="line">      props.getFieldValue(&#x27;groups&#x27;)[index].disabled</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">  // 组件通过props拿到form表单实例,通过getFieldValue(&#x27;groups&#x27;)拿到动态表单数据,然后通过Form.List的index设置disabled</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/react-note-1/" data-id="ckqt4myhk00018kuee9zz4th0" data-title="react antd之动态创建表单" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-js-note-5" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/js-note-5/" class="article-date">
  <time class="dt-published" datetime="2021-06-23T11:12:48.000Z" itemprop="datePublished">2021-06-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javaScript/">javaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/js-note-5/">javaScript之apply/call关键字实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let student = &#123;</span><br><span class="line">    name:&#x27;yh&#x27;,</span><br><span class="line">    study:function()&#123;</span><br><span class="line">        console.log(this.name+&#x27;正在学习手写call&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">student.study() // &#x27;yh正在学习手写call&#x27;</span><br><span class="line"></span><br><span class="line">let student2 = &#123;</span><br><span class="line">    name:&#x27;reba&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">student2.study = student.study</span><br><span class="line">student2.study() // &#x27;reba正在学习手写call&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/js-note-5/apply%E5%8E%9F%E7%90%86.jpg" alt="&#39;原理&#39;"></p>
<h2 id="apply-实现"><a href="#apply-实现" class="headerlink" title="apply 实现"></a>apply 实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall=function(context)&#123;</span><br><span class="line">    // 获取上下文</span><br><span class="line">    let ctx = context || window</span><br><span class="line">    // 绑定this指向,指向调用myCall的函数对象</span><br><span class="line">    ctx.fn = this</span><br><span class="line">    // 获取参数</span><br><span class="line">    let param = Array.from(arguments).shift()</span><br><span class="line">    // 执行</span><br><span class="line">    let result = ctx.fn(...param)</span><br><span class="line">    // 删除属性</span><br><span class="line">    delete ctx.fn</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-tips</p>
<p><span style="color:red">call 的实现原理和 apply 的基本一致,只是参数不同</span></p>
<h2 id="call-实现"><a href="#call-实现" class="headerlink" title="call 实现"></a>call 实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function(context)&#123;</span><br><span class="line">    let ctx = context || window</span><br><span class="line">    ctx.fn = this</span><br><span class="line">    if(argumetns[1])&#123;</span><br><span class="line">        result = context.fn(arguments)</span><br><span class="line">    &#125;esle &#123;</span><br><span class="line">        result = context.fn()</span><br><span class="line">    &#125;</span><br><span class="line">    delete ctx.fn</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/js-note-5/" data-id="ckqa8fyxw0000gwuecatvgxda" data-title="javaScript之apply/call关键字实现" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-js-note-4" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/js-note-4/" class="article-date">
  <time class="dt-published" datetime="2021-06-21T07:31:12.000Z" itemprop="datePublished">2021-06-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javaScript/">javaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/js-note-4/">javaScript之new关键字实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>-new 关键字是用来创建实例的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function myNew() &#123;</span><br><span class="line">      // 创建一个无原型的对象</span><br><span class="line">      var obj = Object.create(null)</span><br><span class="line">      // 获取上下文</span><br><span class="line">      var context = Array.prototype.shift.call(arguments)</span><br><span class="line">      // 给obj设置原型</span><br><span class="line">      Object.setPrototypeOf(obj, context.prototype)</span><br><span class="line">      // 调用call方法,改变this指向,使其指向obj</span><br><span class="line">      var result = context.apply(obj, arguments)</span><br><span class="line">      return typeof result === &#x27;object&#x27; ? result : obj</span><br><span class="line">    &#125;</span><br><span class="line">// 测试</span><br><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">let p = myNew(Person,&#x27;yh&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="/js-note-4/%E6%89%8B%E5%86%99new.jpg" alt="&#39;手写new&#39;"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/js-note-4/" data-id="ckq9dlddv000064ue93cl6wje" data-title="javaScript之new关键字实现" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-js-note-3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/js-note-3/" class="article-date">
  <time class="dt-published" datetime="2021-06-18T09:08:56.000Z" itemprop="datePublished">2021-06-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javaScript/">javaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/js-note-3/">javaScript之继承</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>作用:</p>
<p><span style="color:red">解决实例对象间数据共享的方案</span></p>
<ol>
<li>原型链继承</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">    this.age = age</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">// Person原型上添加study方法</span><br><span class="line">Person.prototype.study = function()&#123;</span><br><span class="line">    console.log(`正在学习javaScript继承`)</span><br><span class="line">&#125;</span><br><span class="line">// Person原型上添加selfProperty属性(一般不这样做)</span><br><span class="line">Person.prototype.selfProperty=&#123;</span><br><span class="line">    height:&#x27;170cm&#x27;,</span><br><span class="line">    weight:&#x27;60kg&#x27;</span><br><span class="line">&#125;</span><br><span class="line">function Student(studyContent)&#123;</span><br><span class="line">    this.studyContent = studyContent</span><br><span class="line">&#125;</span><br><span class="line">// 原型链继承关键点:子类原型指向父类的实例</span><br><span class="line">Student.prototype = new Person()</span><br><span class="line">// 构造函数指向Student</span><br><span class="line">Student.prototype.constructor = Student</span><br><span class="line">let stu = new Student(&#x27;prototype&#x27;)</span><br><span class="line">let stu2= new Student(&#x27;__proto__&#x27;)</span><br><span class="line">// 获取stu的原型对象</span><br><span class="line">let stuProto = Object.getPrototypeOf(stu)</span><br><span class="line">// 修改stu属性</span><br><span class="line">stuProto.__proto__.selfProperty.weight = 0</span><br><span class="line">//打印stu</span><br><span class="line">stu</span><br><span class="line">//调用原型上的study方法</span><br><span class="line">stu.study()</span><br><span class="line">//打印stu2</span><br><span class="line">stu2</span><br></pre></td></tr></table></figure>

<p><img src="/js-note-3/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF2.jpg" alt="&#39;原型链继承&#39;"></p>
<p>核心:<br><span style="color:red"><br>子类构造函数指向父类实例<br></span></p>
<p>缺点:</p>
<ol>
<li>初始化子类实例的时候 父类属性不能得到初始化</li>
<li>其中一个子类实例修改了父类原型上的<span style="color:red">引用变量</span>的属性时,其他子类实例共享这个修改</li>
</ol>
<h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Animal(type,color)&#123;</span><br><span class="line">    this.type = type</span><br><span class="line">    this.color = color</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.eat = function()&#123;</span><br><span class="line">    console.log(&#x27;吃&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">function Dog(kind)&#123;</span><br><span class="line">    // 构造函数继承关键点</span><br><span class="line">    Animal.call(this,&#x27;走兽&#x27;,&#x27;white&#x27;)</span><br><span class="line">    this.kind = kind</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.constructor = Dog</span><br><span class="line">let dog1 = new Dog(&#x27;中华田园犬&#x27;)</span><br><span class="line">// 打印dog1</span><br><span class="line">dog1</span><br></pre></td></tr></table></figure>

<p><img src="/js-note-3/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF.jpg" alt="&#39;构造函数继承&#39;"></p>
<p>核心:<br><span style="color:red">子类构造函数中调用父类构造函数</span></p>
<p>优点:</p>
<ol>
<li>能够初始化父类的属性</li>
</ol>
<p>缺点:</p>
<ol start="2">
<li>实例一个子类实例,调用两次构造函数(父类一次,子类一次)</li>
<li>父类原型上的方法不能继承</li>
</ol>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Animal(type,color)&#123;</span><br><span class="line">    this.type = type</span><br><span class="line">    this.color = color</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.eat = function()&#123;</span><br><span class="line">    console.log(&#x27;吃&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">function Dog(kind)&#123;</span><br><span class="line">    // 构造函数继承关键点</span><br><span class="line">    Animal.call(this,&#x27;走兽&#x27;,&#x27;white&#x27;)</span><br><span class="line">    this.kind = kind</span><br><span class="line">&#125;</span><br><span class="line">// 子类原型指向父类实例</span><br><span class="line">Dog.prototype = new Animal()</span><br><span class="line">Dog.prototype.constructor = Dog</span><br><span class="line">let dog1 = new Dog(&#x27;中华田园犬&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="/js-note-3/%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF.jpg" alt="&#39;组合继承&#39;"></p>
<p>核心:</p>
<ol>
<li>子类原型指向父类实例</li>
<li>子类构造函数中调用父类构造函数</li>
</ol>
<p>优点:</p>
<ol>
<li>可以向父类构造函数传参</li>
<li>避免了父类中引用属性在子类中共享的问题</li>
<li>父类原型链上的方法子类也可以共享\</li>
</ol>
<p>缺点:</p>
<ol>
<li>调用父类两次构造函数(实例化一次,子类 prototype 指向父类实例一次)</li>
</ol>
<h2 id="组合继承优化-一"><a href="#组合继承优化-一" class="headerlink" title="组合继承优化(一)"></a>组合继承优化(一)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Animal(type,color)&#123;</span><br><span class="line">    this.type = type</span><br><span class="line">    this.color = color</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.eat = function()&#123;</span><br><span class="line">    console.log(&#x27;吃&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">function Dog(kind)&#123;</span><br><span class="line">    // 构造函数继承关键点</span><br><span class="line">    Animal.call(this,&#x27;走兽&#x27;,&#x27;white&#x27;)</span><br><span class="line">    this.kind = kind</span><br><span class="line">&#125;</span><br><span class="line">// 关键点:子类原型指向父类原型</span><br><span class="line">Dog.prototype = Animal.prototype</span><br><span class="line">Dog.prototype.constructor = Dog</span><br><span class="line">let dog1 = new Dog(&#x27;中华田园犬&#x27;)</span><br><span class="line">// 打印dog1</span><br><span class="line">dog1</span><br></pre></td></tr></table></figure>

<p>优点:</p>
<ol>
<li>在子类构造函数中可以向父类的构造函数中传递参数</li>
<li>避免了父类中的引用类型属性在子类中共享的问题</li>
<li>父类原型对象上的方法子类也可以继承到</li>
<li>父类构造函数只调用一次</li>
</ol>
<p>缺点:</p>
<ol>
<li>向子类原型上增加属性或方法时会影响到父类原型</li>
</ol>
<h2 id="组合继承优化-二"><a href="#组合继承优化-二" class="headerlink" title="组合继承优化(二)"></a>组合继承优化(二)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Animal(type,color)&#123;</span><br><span class="line">    this.type = type</span><br><span class="line">    this.color = color</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.eat = function()&#123;</span><br><span class="line">    console.log(&#x27;吃&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">function Dog(kind)&#123;</span><br><span class="line">    // 构造函数继承关键点</span><br><span class="line">    Animal.call(this,&#x27;走兽&#x27;,&#x27;white&#x27;)</span><br><span class="line">    this.kind = kind</span><br><span class="line">&#125;</span><br><span class="line">// 关键点:利用Object.create()</span><br><span class="line">Dog.prototype = Object.create(Animal.prototype)</span><br><span class="line">Dog.prototype.constructor = Dog</span><br><span class="line">let dog1 = new Dog(&#x27;中华田园犬&#x27;)</span><br><span class="line">// 打印dog1</span><br><span class="line">dog1</span><br></pre></td></tr></table></figure>

<p><span style="color:red">实现继承的常用方式,优点就是弥补了以上继承方式的所有缺点</span></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/js-note-3/" data-id="ckq276mu20000kkueboh2am3x" data-title="javaScript之继承" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-js-note-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/js-note-2/" class="article-date">
  <time class="dt-published" datetime="2021-06-18T04:55:02.000Z" itemprop="datePublished">2021-06-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javaScript/">javaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/js-note-2/">javaScript之函数节流与函数防抖</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><p>概念:</p>
<p>单位时间内触发多次事件,只执行一次其事件对应的回调函数</p>
<p>实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">延迟执行版本:</span><br><span class="line">function throttle(fn,delay)&#123;</span><br><span class="line">    var timer = null</span><br><span class="line">    return function()&#123;</span><br><span class="line">        if(timer)&#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(()=&gt;&#123;</span><br><span class="line">            fn.apply(this,arguments)</span><br><span class="line">            timer = null</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">立即执行版本:</span><br><span class="line">function throttle(fn,delay=500)&#123;</span><br><span class="line">    let startTime = Date.now()</span><br><span class="line">    return function()&#123;</span><br><span class="line">        let endTime = Date.now()</span><br><span class="line">        let diffValue = endTime - startTime</span><br><span class="line">        if(diffValue &gt;= delay)&#123;</span><br><span class="line">            fn.call(this,arguments)</span><br><span class="line">            startTime = Date.now()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解:</p>
<p>在单位事件内,不论触发多少次事件,只执行第一次事件对应的回调函数,并且在计时结束后相应(只认<span style="color:red">第一次事件的回调</span>)</p>
<p>运用:<br><img src="/js-note-2/throttle.jpg" alt="&#39;节流&#39;"></p>
<h2 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h2><p>概念:</p>
<p>事件触发后,在规定的时间后(单位时间)执行其事件对应的回调函数;如果在单位事件内再次触发事件,则重新计时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function debunce(fn, delay = 500) &#123;</span><br><span class="line">    var timer = null</span><br><span class="line">    return function () &#123;</span><br><span class="line">    if (timer) &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">        fn.apply(this, arguments)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解:</p>
<p>利用闭包将 timer 挂载到 window 上,每次触发事件就把上一次 timer 清除掉,直到最后一次事件执行回调函数(<span style="color:red">只认最后次</span>)</p>
<p>运用:</p>
<p><img src="/js-note-2/debunce.jpg" alt="&#39;防抖&#39;"><br>作用:</p>
<span style="color:red">
优化高频率执行回调(例如:resize、keypress、scroll、mousemove等事件的回调)
</span>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/js-note-2/" data-id="ckq21ga0u0000iwue6cz1cz86" data-title="javaScript之函数节流与函数防抖" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-js_note_1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/js_note_1/" class="article-date">
  <time class="dt-published" datetime="2021-06-17T09:59:12.000Z" itemprop="datePublished">2021-06-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javaScript/">javaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/js_note_1/">javaScript之闭包</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>概念:</p>
<p>MDN 的解释:<span style="display:inline-block;background:black">一个函数和对其(lexical environmet)词法环境的引用捆绑在一起 就叫做闭包</span><br> 我的理解是 闭包是一种现象:</p>
<ol>
<li>函数嵌套</li>
<li>内部函数引用外部函数的变量</li>
<li>外部函数被调用(也就是参数或者变量不会被垃圾回收机制回收)</li>
</ol>
<p>满足了这三点的现象就是闭包</p>
<p>作用:</p>
<ol>
<li>创建我们自己的私有变量,可以避免变量全局污染</li>
<li>内部函数能够访问到其外层函数的作用域</li>
<li>可以在内存中一直保存变量</li>
</ol>
<p>缺点:</p>
<ol>
<li>由于变量会一直保存在内存中,使用不善的话,会造成<span style="color:red">内存溢出</span></li>
</ol>
<p>这就是最简单的闭包:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function person()&#123;</span><br><span class="line">    var name = &#x27;tom&#x27;</span><br><span class="line">    return function getName()&#123;</span><br><span class="line">        console.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var closure = person()</span><br><span class="line">console.log(&#x27;查看闭包&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="/js_note_1/closure.jpg" alt="&#39;闭包&#39;"></p>
<ol>
<li>闭包为什么可以实现在函数外读取到函数内的变量？</li>
</ol>
<p><span style="color:rgb(255, 0, 0);">原因: person 是 getName 的父作用域, getName 被赋值给一个全局变量, getName 始终存在在内存中, getName 的存在又依赖 person, 因此 person 也始终存在内存中, 不会在调用结束后被垃圾回收机制回收</span></p>
<ol start="2">
<li>闭包使用场景之封装私有变量</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var counter = (function()&#123;</span><br><span class="line">    var privateCount = 0// 私有变量</span><br><span class="line">    function changeCount(value)&#123;</span><br><span class="line">        privateCount  += value</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        // 闭包</span><br><span class="line">        increment:function()&#123;</span><br><span class="line">            changeCount(1)</span><br><span class="line">            console.log(&#x27;调用increment:&#x27;,privateCount)</span><br><span class="line">        &#125;,</span><br><span class="line">        decrement:function()&#123;</span><br><span class="line">            changeCount(-1)</span><br><span class="line">            console.log(&#x27;调用decrement:&#x27;,privateCount)</span><br><span class="line">        &#125;,</span><br><span class="line">        getValue:function()&#123;</span><br><span class="line">            return privateCount</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p><img src="/js_note_1/%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%80.jpg" alt="&#39;使用场景&#39;"></p>
<blockquote>
<p>当然,闭包还有其他使用场景,有时间了再进行补充</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/js_note_1/" data-id="ckq0s08g40001e8ue8y0k5c5f" data-title="javaScript之闭包" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-vue2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/vue2/" class="article-date">
  <time class="dt-published" datetime="2021-05-24T08:23:22.000Z" itemprop="datePublished">2021-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/vue2/">vue2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<p>响应式原理<br>会先对 data option 中的数据进行观察<br>如果观测的数据是一个对象<br>递归遍历当前对象属性,通过 object.defineProperty 的形式给每个属性添加 get,set 方法<br>也给每个属性实例化 Dep,每个属性都有自己的 dep 实例<br>在 get 中收集依赖 watcher<br>在 set 中通知 watcher 更新 UI<br>如果观测的数据是一个数组<br>会劫持数组原型上的方法,进行重写 在重写的方法中会收集当前数组的依赖 然后在观测阶段把数组的原型设置为重写后</p>
<p>let data = {<br>name:’yh’<br>}</p>
<p>const oldPrototype = Array.prototype<br>const proto = Object.create(oldPrototype)<br>[‘push’,’shift’,’unshift’,’pop’,’sort’,’reverse’,’splie’].forEach(element =&gt;{<br>proto[element] = function(){<br>oldPrototype[element].apply(this,arguments)<br>// 收集依赖<br>}<br>})</p>
<p>function observe(target){<br>if(typeof target !=’object’ || null == target){<br>return<br>}<br>if(Array.isArray(target)){<br>// 设置原型<br>Object.setPrototypeOf(target,proto)<br>// 对元素进行观测<br>for(let i=0 ; i &lt; target.length; i++&gt;){<br>observe(target[i])<br>}<br>}else{<br>Object.keys(target).forEach(key =&gt;{<br>defineReactive(key,target[key],target)<br>})<br>}<br>}</p>
<p>function defineReactive(key,value,target){<br>observe(newValue)<br>Object.defineProperty(target,key,{<br>get(){<br>// 收集依赖<br>return value<br>},<br>set(newValue){<br>value = newValue<br>observe(newValue)<br>// 通知 watcher 更新视图<br>}<br>})<br>}</p>
<hr>
<hr>
<p>vue3 响应式原理</p>
<p>function observe(target){</p>
<p>const handlers = {<br>get(target,key,value){<br>return Reflect.get(target,key)<br>},<br>set(target,key,value){<br>let flag = Reflect.set(target,key,value)<br>},<br>deleteProperty(target,key,value){<br>return Relect.deleteProperty(target,key)<br>}<br>}</p>
<p>let result = new Proxy(target,handlers)<br>return result<br>}</p>
<hr>
<hr>
<p>模板编译<br>1:模板解析,将用户的模板通过正则等一系列方式转换成 AST 抽象语法树<br>2:遍历优化 AST,标记静态节点和静态根节点(在 diff 的 patching 算法中可以跳过静态节点)<br>3:最后再将 AST 转换成渲染函数 render</p>
<hr>
<hr>
<p>v-if 和 v-show 的区别<br>v-if 的表达式如果为 false,dom 元素都不创建,只有当表达式为 true 的时候,才会去创建元素<br>v-show 只是用 css 的 displ 属性进行切换<br>从源码上来看 含有 v-if 的节点在转换成 ast 抽象语法树,再将 AST 转成渲染函数 render 的代码来看,是一个三元表达式,只有为 true 的时候,才会去创建元素<br>false 的时候 是调用的创建空元素的方法</p>
<p>含有 v-show 的节点 从 AST 转成的渲染函数 的代码中可以知道 v-show 被截取,被放到了指令的集合中去<br>当表达式为 false 的时候,设置节点的 display 属性为 none</p>
<hr>
<p>v-for 的优先级更高<br>从源码来看<br>有 v-for 和 v-if 的节点转换成的 render 函数中代码中<br>先 loop 节点,再在每个节点中的用一个三元运算符来描述 v-if 的作用,所以是先进行遍历,再考虑是否渲染<br>如果遍历的数量太多,都要进行三元运算,所以性能狠低</p>
<hr>
<hr>
<p>nextTick 原理<br>事件循环机制<br>nextTick 主要是使用了宏任务和微任务定义了一个异步方法</p>
<p>首先修改数据，这是同步任务。同一事件循环的所有的同步任务都在主线程上执行，形成一个执行栈，此时还未涉及 DOM 。<br>Vue 开启一个异步队列，并缓冲在此事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。</p>
<p>同步任务执行完之后,才会去任务队列中读取回调函数,等待主线程执行,然后更新 dom<br>如果环境支持,nextTick 内部是用 promise.then,MutationObserver, setImmediate 等<br>如果环境不支持,采用的 setTimeout 来实现异步</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/vue2/" data-id="ckp2gyxag0000a8ve3t179wvx" data-title="vue2" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-notes" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/notes/" class="article-date">
  <time class="dt-published" datetime="2021-01-23T02:36:44.000Z" itemprop="datePublished">2021-01-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javaScript/">javaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/notes/">notes</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<p>闭包<br>MDN 上是这样解释的:一个函数和对其 lexical environmet 词法环境的引用捆绑在一起 就叫做闭包<br>我的理解是 闭包是一种现象,函数嵌套,内部函数引用外部函数的变量,外部函数被调用,也就是参数或者变量不会被垃圾回收机制回收 这是就形成了闭包<br>优点 1:创建我们自己的私有变量,可以避免变量全局污染<br>优点 2:内部函数能够访问到其外层函数的作用域<br>优点 3:可以在内存中一直保存变量<br>缺点 1:由于变量会一直保存在内存中,使用不善的话,会造成内存溢出</p>
<hr>
<hr>
<p>函数节流<br>概念:单位时间触发多次事件,只执行一次其事件对应的回调函数,就叫函数节流<br>如果 setTimeout 的返回值存在 就不执行函数 执行了回调函数后会把 timer 重置为 null</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fun,delay)&#123;</span><br><span class="line">    let timer = null</span><br><span class="line">    return function()&#123;</span><br><span class="line">        if(timer)&#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(&#123;</span><br><span class="line">        fun.apply(this,arguments)</span><br><span class="line">            timer = null</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>函数防抖<br>概念:触发事件后,在规定的时间后执行其对应的回调函数,如果在规定的时间内又触发了事件,则重新计时<br>将 setTimeout 的返回值挂载到 window 上,每次触发事件都会把上次的 timer 清除了,直到最后次无法清除,再执行回调函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function debunce(fun,delay)&#123;</span><br><span class="line">    let timer = null</span><br><span class="line">    return function()&#123;</span><br><span class="line">        if(timer)&#123;</span><br><span class="line">            cleanTimeout(timer)</span><br><span class="line">            timer = null</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(&#123;</span><br><span class="line">            fun.apply(this,arguments)</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>继承<br>解决实例对象间属性共享的方案<br>1:原型链继承<br>核心:子类原型指向父类的实例<br>缺点 1:子类所有实例都共享父类原型上的属性,如果一个实例修改了父类原型上的引用变量,其他实例也会共享这个修改<br>缺点 2:实例化的时候无法向父类构造函数传参,也就无法初始化父类的属性<br>child.prototype = new Father()</p>
<p>2:构造函数继承:<br>核心:在子类的构造函数中调用父类构造函数<br>缺点 1:无法共享父类原型链上的属性<br>function Children(){<br>Father.apply(this,arguments)<br>}<br>3:组合继承:<br>核心:子类的构造函数中调用父类构造函数;子类原型指向父类的实例<br>优点 1:可以向父类构造函数传参<br>优点 2:避免了父类中引用属性在子类中共享的问题<br>优点 3：父类原型链上的方法子类也可以共享<br>缺点:调用父类两次构造函数(实例化一次,子类 prototype 属性指向父类实例一次)<br>4:原型继承<br>核心:子类 prototype 属性指向父类的原型</p>
<p>5:原型继承升级版<br>核心:子类 prototype 属性指向父类的原型的浅拷贝</p>
<hr>
<hr>
<p>js 的数据类型<br>js 有两种数据类型:基本数据类型;引用数据类型<br>基本数据类型:String Number Boolean undefined Null bigInt Symbol<br>引用数据类型:数组 函数 对象</p>
<hr>
<hr>
<p>let const var 的区别<br>1: var 声明的变量有变量提升 未声明先使用不会报错,该变量的值是 undefined<br>2: var 声明的变量会自动挂载到 window 上,let const 不会<br>3: let const 声明的变量不存在变量提升,但是会有暂时性死区,就是未声明先使用,会报错<br>4: let const 在同一个作用域中不能重复声明同一个变量 var 可以<br>5: let var 声明变量可以不初始化,默认为 undefined const 声明必须初始化<br>6: const 声明是常量 如果是基本数据类型,变量不可修改 如果是引用数据类型 变量的属性是可以修改的 是地址不能改</p>
<hr>
<hr>
<p>undefined 和 null 的区别<br>1：undefined,null 都是基本数据类型中一种,他们的值都只有一个 就是 undefined 和 null<br>2：undefined 变量已经声明但是并未初始化的值就是 undefined<br>3: null 一般用来表示给将要返回为对象的变量的初始化<br>4: typeof undefined 为 undefined<br>5: typeof null 为 object 计算机语言是二进制<br>因为 js 底层用前三位占位符为 000 来表示对象, null 二进制全是 0</p>
<hr>
<hr>
<p>实参 形参<br>形参:在声明函数时,函数定义的参数<br>实参:在调用函数时,传递给函数的参数</p>
<hr>
<hr>
<p>JS 中的传参策略<br>不管对于值类型还是引用类类型，都是按值传递的<br>对于 js 中的变量，值类型存放在栈中，引用类型的地址存放在栈中，对应的值存放在堆中。当传参发生的时候，值类型会直接将栈中的值进行复制，形参和实参此时实际上是两个完全不相干的变量。对于引用类型，传参发生时，会将实参变量位于栈中的地址进行复制，此时栈中会有两个指向同一个堆地址的指针。</p>
<hr>
<hr>
<p>深度克隆和浅克隆<br>浅克隆<br>function copy(target){<br>let result<br>if(typeof target !=’object’ || target === null){<br>return target<br>}<br>result = Array.isArray(target)?[]:{}<br>for(let key in target){<br>result[key] = typeof target[key] === ‘object’ ?copy(target(key)) : target(key)<br>}<br>return result<br>}</p>
<hr>
<hr>
<p>事件循环机制</p>
<p>浏览器内核大致可以分为 GUI 渲染引擎,js 引擎,时间管理引擎,回调函数引擎,http 请求引擎<br>其中 js 引擎是专门处理 js 脚本任务的<br>javaScript 是单线程的,但是他有一个特点是”非阻塞”的<br>首先 js 处理任务是有一个主线程和一个调用栈的<br>调用栈是先进后出,执行的任务会置顶,执行完会就会移除<br>js 任务我们可以分为同步任务和异步任务<br>同步任务会进入调用栈排队等待执行,遇到异步任务,依次把异步任务放入一个队列,并且会在 eventTable 中注册回调函数<br>当主线程处理完同步任务后,调用栈被清空的时候,会去任务队列中依次读取任务,取出相应的回调函数进行执行<br>任务队列是先进先出的<br>如此的读取执行 读取执行 反复操作 就是这个事件循环机制了</p>
<p>那么除了广义上区分的同步任务和异步任务 还可以分为宏任务和微任务<br>当 js 引擎执行第一次事件循环的时候,也就是循环整个 script 代码的时候,中途遇到了微任务,会把微任务放入微任务队列,当这个宏任务执行完之后,会去微任务队列读取任务,如果有,则依次读取微任务,取出起相应的回调函数并执行<br>只有当当前微任务队列中的任务执行完了之后,浏览器才会去渲染 UI 或者才会去执行下一个宏任务,如此反复,就是 js 的事件循环机制了<br>宏任务:script,setTimeout,setInterval,setImmediate,I/O,UI Rending<br>微任务:process.nextTick,promise.then,mutationObserve</p>
<hr>
<hr>
<p>手写 call 函数<br>Function.prototype.myCall = function (context){<br>if(typeof this != ‘function’){<br>return ‘type Error’<br>}<br>let args = […arguments].slice(1)<br>context = context || window<br>context.fn = this<br>let result = null<br>result = context.fn(…args)<br>delete context.fn<br>return result<br>}</p>
<hr>
<hr>
<p>手写 apply 函数<br>Funciton.prototype.myApply = function(context){<br>if(typeof this != ‘function’){<br>return ‘type error’<br>}<br>context = context || window<br>context.fn = this<br>if(argumetns[1]){<br>result = context.fn(arguments)<br>}esle {<br>result = context.fn()<br>}<br>return result<br>}</p>
<hr>
<hr>
<p>手写 new 方法<br>function myNew(){<br>let obj = {} // 创建新对象<br>let context = Array.prototype.shift.call(arguments) // 获取构造函数<br>if(typeof context === ‘function’){<br>Object.setPrototypeOf(obj,context.prototype)<br>}else {<br>Object.setPrototypeOf(obj,null)<br>}<br>let result = context.apply(obj,arguments)<br>return typeof result ==’object’? result :obj<br>}</p>
<hr>
<hr>
<p>原型以及原型链<br>js 可以说是一门基于原型的语言,当通过构造函数创建对象后,多个对象之间怎么共享属性?<br>或者说 实例对象和构造函数之间怎么动态联系起来 就引出了一个对象 叫原型对象<br>1:在 js 中所有的实例对象都有个<strong>proto</strong>属性(null 除外)<br>2:在 js 中所有的函数都有个 prototype 属性(箭头函数除外),默认指向一个 object 的空对象<br>3:实例的<strong>proto</strong>属性指向其对应的构造函数的原型对象<br>4:构造函数的 prottotype 属性也指向其原型对象,所以实例的<strong>proto</strong>属性 === 构造函数.prototype<br>5:当查找对象的某个属性的时候,首先会在对象本身的属性中查找,如果找到了就返回其映射的值,<br>如果找不到,就会沿着对象的<strong>proto</strong>属性 也就是会到对象的原型对象上去找,如果还找不到 会去原型的原型对象上去找,这样一直找下去,就形成了原型链,规定:js 原型的尽头是 object.prototype.<strong>proto</strong> = null,如果还找不到 就返回 undefined<br>普通对象的构造函数都是 Object()<br>函数对象的构造函数都是 Function()<br>Object()的构造函数也是 Function()<br>Function()的构造函数是它自己</p>
<hr>
<hr>
<p>webpack 优化<br>(一)<br>1:自带优化:生产环境会使用 tree-shaking 分析文件的依赖关系,没使用的代码不打包<br>2:scope-hoisting —&gt; 作用域提升,变量的结果会直接打包在文件中<br>(二)<br>1:打包速度的优化:开启多线程打包<br>2:打包体积的优化:<br>按需引入,使用的第三方 UI 可以按需引入,比如 echart,elementUI 等<br>语言国际包:一般都有很多其他国家的语言(momendjs)<br>使用 babel-preset 处理 es6 语法的时候,默认会把所有的 es6 转换后的语法都打包到文件中去,使用<br>useBuiltIn:’usage’方式 把使用到的语法转换后打进文件中去<br>动态链接库 CDN 的方式引入 把体积大的包放到 cdn 上 webpack.dllPlugin(生成动态链接库) DllReferencePlugins(引用动态链接库)</p>
<hr>
<hr>
<p>从输入 url 到页面加载完成发生了什么？——前端角度<br>1:DNS 域名解析,将域名还原成 ip 的一个过程<br>2:TCP 连接（3 次握手）<br>3:完成握手后开始发送数据 发起请求<br>4:服务器响应请求 返回资源<br>5:拿到资源 进行渲染</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/notes/" data-id="ckpgo4u6a0000lwveagc86ha8" data-title="notes" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/javaScript/">javaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/react-antd/">react antd</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/react-note-1/">react antd之动态创建表单</a>
          </li>
        
          <li>
            <a href="/js-note-5/">javaScript之apply/call关键字实现</a>
          </li>
        
          <li>
            <a href="/js-note-4/">javaScript之new关键字实现</a>
          </li>
        
          <li>
            <a href="/js-note-3/">javaScript之继承</a>
          </li>
        
          <li>
            <a href="/js-note-2/">javaScript之函数节流与函数防抖</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 SuperTg<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>